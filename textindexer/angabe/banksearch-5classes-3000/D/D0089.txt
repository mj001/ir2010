
Absolute Java - Java Tidbits
Know Your Primitive Type
 
 Data Type
	Bits
	Minimum Value
 Maximum Value
 
 
 byte 
	8 
	 
	&#8209;128==&#8209;27
 (Byte.MIN_VALUE) 
	127==27&#8209;1
 (Byte.MAX_VALUE) 
 
 short 
	16 
	 
	&#8209;32,768==&#8209;215
 (Short.MIN_VALUE) 
	 
	32,767==215&#8209;1
 (Short.MAX_VALUE) 
 
 char 
	16 
	0
 (Character.MIN_VALUE) 
	 
	65,535==216&#8209;1
 (Character.MAX_VALUE) 
 
 int 
	32 
	 
	&#8209;2,147,483,648==&#8209;231
 (Integer.MIN_VALUE) 
	 
	2,147,483,647==231&#8209;1
 (Integer.MAX_VALUE) 
 
 long 
	64 
	 
	&#8209;9,223,372,036,854,775,808==&#8209;263
 (Long.MIN_VALUE) 
	 
	9,223,372,036,854,775,807==263&#8209;1
 (Long.MAX_VALUE) 
 
 float 
	32 
	1.40129846432481707e&#8209;45*
 (Float.MIN_VALUE) 
	3.40282346638528860e+38
 (Float.MAX_VALUE) 
 
 double 
	64 
	4.94065645841246544e&#8209;324*
 (Double.MIN_VALUE) 
	1.7976931348623157e+308
 (Double.MAX_VALUE) 
	
	* For both the
 float and double data types the minimum value shown
 above is the smallest positive value. Of course, both float
 and double support negative numbers as well. The smallest negative
 number that can be represented in a float, for example, is &#8209;Float.MAX_VALUE.
 The largest negative number that can be represented in a float
 is &#8209;Float.MIN_VALUE. 
 
Currency Symbols and Identifiers
Identifiers cannot begin with a digit (as defined by the Unicode character set).
Currency symbols are treated as any other alphabetic character for the sake of
naming identifiers (e.g., £347_00, $18$, and ¥Price
are acceptable).
The following code will print the hex values for all the characters that qualify
 as "currency symbols":
1 public class CurrencyCharIdentifier { 
2 public static void main(String[] args) { 
3 for(char c = 0; c Test Your Java Knowledge
 article to see a clear example of Java's default initialization behavior
 and how it can lead to surprising results&#151;pay attention to the values assigned
 to the Bvar variable in that example and when they're assigned.
	
 
 Data TypeDefault Value
 (if no initial value is specified)
 
 byte 0 
 
 short 0 
 
 char '\u0000' 
 
 int 0 
 
 long 
	0L 
	
 
 float +0.0F 
 
 double +0.0D 
 
 boolean 
	false 
 
 Object Reference null 
 
Static variables are initialized to their default values (or to the 
 value specified in an initializer) when the class is loaded while instance variables 
 are initialized to their default values (or to the value specified in an initializer) 
 when an instance of the class is created. Local variables are never initialized 
 to default values&#151;you must always explicitly initialize local 
 variables before referencing them. Local variable initialization can occur in 
 an initializer or an assignment. 
 
 Elements of an array are always initialized to their default values (or to the 
 value specified in an initializer)&#151;even if the array is a local variable. 
 In the code below, each of the array's ten elements is initialized to its default 
 value (false, in this case) automatically when the array is created: 
boolean[] b = new boolean[10]; // all ten elements are false
 
Modifier Restrictions
	
All interfaces and the methods within them are implicitly abstract and may superfluously be declared as such.
	
All methods within an interface are implicitly public (as well as abstract) and may superfluosly be declared as such.
	
All fields within an interface are implicity public and static and may superfluosly be declared as such.
Methods declared as abstract (including methods declared in interfaces) cannot
 be declared static, final, synchronized,
 native or strictfp. Methods declared in an interface (which are, of course, abstract methods) will always have public visibility (even if no visibility modifier is specified) while abstract methods in a class (which must be an abstract class if it contains at least one abstract method) may have protected visibility as well. Non-abstract methods in an abstract class may have any visibility.
A constructor cannot be declared abstract, static, final, synchronized, native or strictfp.
See the code below and its embedded comments for a summary of how abstract class, interfaces, and their members may be declared.
 
 
	
	1 
	 abstract class Abner { 
	
	
	2 
	 public abstract void a(); 
	
	
	3 
	 protected abstract void b(); 
	
	
	4 
	 abstract void c(); 
	
	
	5 
	 //private abstract void c(); // private causes compiler error 
	
	
	6 
	 private int d() { return 10; } // non-abstract methods can have any visibility 
	
	
	7 
	 } // Abner 
	
	
	8 
	 
	
	
	9 
	 abstract interface Barney { // abstract is optional 
	
	10 
	 int zz = 16; // is considered public and static 
	
	
	11 
	 public abstract void a(); 
	
	
	12 
	 //protected abstract void b(); // protected causes compiler error 
	
	
	13 
	 abstract void c(); // is considered public 
	
	
	14 
	 //private abstract void c(); // private causes compiler error 
	
	
	15 
	 } // Barney 
	
Blank Final Variable Initialization
A blank final variable is a variable declared as final
 but not assigned a value in its declaration. Like any variable, a blank final
 variable can be either an instance variable or a class (i.e.,
 static) variable. Java requires all blank final instance variables
 to be explicitly initialized before an instance of the class can be created
 (i.e., by the time each constructor completes execution). Similarly, a blank
 final class variable must be explicitly assigned a value as part
 of the class initialization process (JLS
 2, §8.3.1.2).
 
The code below will hopefully make clear the fact that blank final variables
 must be assigned a value once and only once. Remember that initializers
 (instance and static) are executed in the order in which they appear in the
 code and that all instance initializers are executed before constructors.
 
1 public class Tester { 
2 final int i; 
3 final static int c; 
4 
5 Tester() {} 
6 
7 Tester(char x) { 
8 // This assignment statement would cause a compiler error 
9 // since i was already initialized in the instance 
10 // initializer, which executes before any constructor. 
11 // i = x; // compiler error 
12 } // Tester() 
13 
14 static { 
15 System.out.println("The first static init"); 
16 // This assignment statement would cause a compiler error 
17 // since c has not yet been initiaized and therefore, 
18 // cannot be referred to. 
19 // System.out.println("c=" + c); // compiler error 
20 } 
21 
22 static { 
23 System.out.println("The second static init"); 
24 c = 1; 
25 } 
26 
27 static { 
28 // Now, it's safe to refer to c since it's been initialized 
29 // in the previous static initializer. 
30 System.out.println("The third static init, c=" + c); 
31 } 
32 
33 { 
34 System.out.println("the first instance initializer"); 
35 // Referring to i here would cause a compiler error since 
36 // i has not been initialized: 
37 // System.out.println("i=" + i); // compiler error 
38 } 
39 
40 { 
41 System.out.println("The second instance initializer"); 
42 // This is where i gets initialized. Remember, all instance initializers 
43 // are executed *before* the first statement in any constructor. 
44 i = 12; 
45 } 
46 
47 private static void main(String[] args) { 
48 new Tester(); 
49 } // main() 
50 } // Tester 
 
The Mighty + Operator
If either of the two operands to the + operator is a String,
the + performs a String concatenation, converting one
of its two operands to a String, if necessary. If neither operand
is a String Java will attempt to perform addition on the operands
(which may or may not be possible depending on the types of the operands).
If one of the operands to the + operator is a reference type whose
 value is null, the JLS
 2 (§15.18.1.1)
 dictates that the String representation of this reference shall
 be the character string "null". For example, let's say we have
 the following snippet:
1 java.util.HashSet hs = null; 
2 String s = 3 + 9 + "Hello " + Hs; 
After this code executes the variable s will contain the string
 "12Hello null".
As an aside, remember that Java always evaluates operands in an expression
 from left to right on a per operator basis, but will perform operations in the order dictated
 by its rules of precedence. Make sure you understand this rule, otherwise you
 may not always get what you expect: see Question
 5 and Question 9
 in the Test Your Java Knowledge
 article.
Default Constructor Visibility
As you probably know, if you do not provide any constructors for a class Java
provides a default (i.e., "no-arg") constructor automatically. The visibility
of this default constructor is the same as the visibility for the class (either
public or package).
Learning to Love javac's &#8209;classpath, &#8209;sourcepath and &#8209;d Options
There are three command line options for Sun's javac compiler that are a frequent
source of confusion. These options are: &#8209;classpath, &#8209;sourcepath, and &#8209;d. An additional source of confusion is the fact that the &#8209;classpath
option is also used with Sun's Java launcher (Sun's java command) but it's behavior
is slightly different from that of javac.
Throughout this discussion I'll use a directory diagram similar to the example
 shown below. The entries in blue represent Java
 source code files while the entries in red are
 the corresponding class files. All Java source and class files are displayed
 with their fully qualified package names. The example below shows the source
 files for two Java classes: com.abc.Abner and com.abc.def.Tester
 along with their respective class files, com.abc.Abner.class
 and com.abc.def.Tester.class. If you're color&#8209;blind,
 you'll have to focus on the filename extensions (".java" versus ".class"). If you're blind, you may not be able to read this article.
 
C:\
 |
 +--Projects\
 |
 +--com\
 |
 +--abc\
 |
 +--com.abc.Abner.java
 +--com.abc.Abner.class
 |
 +--def\
 |
 +--com.abc.def.Tester.java
 +--com.abc.def.Tester.class
Sun's javac compiler provides a limited form of dependency
 checking. When javac compiles a class, it ensures that any classes referenced by the class currently being compiled are always up to date with their
 corresponding source files, so long as it can find the source files. I'll discuss how javac searches for source files later. For example, let's say we have a source file named
 A.java (containing class A) which references another class, B, contained in B.java. Let's say class B, in turn, uses class C, contained in C.java. So, we have the following dependencies between classes, with each class in a separate source file:
 
A (in A.java) ---> B (in B.java) ---> C (in C.java)
When
 A.java is compiled, the javac compiler will automatically
 compile B.java if it finds that B.java is newer than B.class. While compiling B.java, javac will then check if C.java is newer than C.class and if it is, C.java will be compiled as well. Earlier, I said that javac provided limited dependency checking? By limited I meant that javac only checks the immediate dependencies of the class it is currently compiling. Using the above example, let's say that C.java has been modified since it was last compiled but B.java has not. When A.java is compiled, javac will check only if B.java is newer than B.class. If it is not, B.java will not be compiled nor will javac bother checking if C.class is up to date with C.java. So the dependency checking provided by javac is basically "one&#8209;level" deep.
In the example just presented, you may have noticed that I stressed that each class was contained in a source file bearing the name of the class: class A was in A.java, class B was in B.java, etc. This "class to source file relationship" will not necessarily always be present. Suns's JDK compiler requires that classes marked as public reside in source files bearing the class name. Classes with package visibility, however, may well reside in a source file that has nothing to do with the name of the class. Take a look at the following source code as an example:
1 package com.test; 
2 
3 class Mary {} 
4 
5 class Freddy {} 
This source file contains two classes, both of which have package visibility. You cannot make any inferences about the name of this source file since it does not contain a public class. This source file happens to be named, gigi.java (named after my dog). If a given class, say, Tester, refers to either Mary or Freddy, the javac compiler will have no way of checking whether these two classes were up to date with their source code, since it does not know where the source code for the classes resides. If you were to make any changes to the source file above you would have to explicitly re-compile it to make those changes visible; the source file will not be automatically compiled. When javac checks dependencies, it assumes all referenced classes are in source files bearing the name of the class.
When you run the javac compiler, you specify a list of one or more command line switches and one or more Java source
 code files to be compiled on the javac command line. I'll refer to the classes
 contained in these source code files as the primary classes since these
 are the classes we are explicitly asking the javac compiler to compile. Keep in mind that there could be more than one class per source file. Note that javac allows you the option of specifying command line switches and source file names using an alternative "arguments files" notation. You can simply place all your command line switches and source file names in one or more files and then specify these files on the javac command line using an "@filename" syntax. You can see examples of this in the javac documentation in the JDK.
Each of primary classes may refer to other Java classes which are not
 specified on the command line. Let's call these classes the secondary classes.
 The example below shows a Java source code file, Tester.java and
 the javac command line used to compile it. As you can see, the code within Tester
 refers to another class, Abner. In the command line that follows,
 Tester is a primary class (since it is specified in a source file named on the
 command line) and Abner is a secondary class since it is referenced by Tester but is not in a file specified on the command line:
1 public class Tester { 
2 Abner a = new Abner(); // Tester depends on Abner 
3 } // Tester 
 
C:\Projects>javac
 Tester.java
Incidentally, the C:\Projects>
 shown above is simply the Windows command prompt. Throughout this article the
 Windows command prompt will be shown in bold
 black text and will always indicate the current default directory.
The Java compiler cannot compile your primary classes until it somehow locates
 all the secondary classes upon which the primary classes depend, and it cannot compile the secondary classes until it locates all the classes upon which they depend. In the example
 above, Tester.java cannot be compiled until the Abner
 class file is located. Here's the first nugget of information to remember from
 this article:
 
The Java compiler uses the "classpath setting" (described below)
 in conjunction with the &#8209;sourcepath command line option (if present) to locate
 secondary classes, but not primary classes. 
The "classpath setting" referred to above can be established either
 by setting the CLASSPATH environment variable or by specifying
 the &#8209;classpath command line option to the javac compiler. In either
 case, the setting consists of a combination of directories, Jar, and ZIP files
 which the Java compiler uses to locate secondary class files (as well as secondary source
 files, if the -sourcepath was not specified). If the CLASSPATH
 environment variable has already been set and you also specify the &#8209;classpath
 option, the &#8209;classpath option takes precedence over the CLASSPATH
 environment variable. If neither the CLASSPATH environment variable
 has been set nor the &#8209;classpath option specified, then the default
 classpath is simply the current directory from which the javac command is issued. To simplify this discussion, I'll assume throughout this article that the CLASSPATH environment variable is not set.
Incidentally, if a CLASSPATH environment variable has already
 been set and you wish to use its value in your &#8209;classpath command line
 option, you can do so by embedding the value of the CLASSPATH environment variable within your
 &#8209;classpath command line option. Here's an example for Windows:
 
C:\Projects>javac
 &#8209;classpath ABCDirectory\xyz.zip;%CLASSPATH%;DEFDirectory SomeFile.java 
Before we go on to some examples there are a few other important details you
 must know. This is the second important nugget of information to be remembered
 from this article:
 
 When the Java compiler tries to locate a secondary class it actually
 tries mightily to locate both the class file and the corresponding source file:
 
 
- If it can locate a class file but no source file, it uses the class
 file.
	 
- If it can locate the source file but no class file it compiles the
 source file and uses the resulting class file.
	 
- If it can locate both a source and class file it checks if the source
 file is newer than the class file. If it is, it compiles the source file
 and uses the resulting class file.
 
If the -sourcepath option has not been specified, the Java
 compiler will look for source files in the same manner it looks for class files&#151;by using the "classpath setting",
 as described above. If the -sourcepath option was specified,
 the Java compiler will look for source files only in those directories specified
 by the &#8209;sourcepath option, ignoring any source code files that might be present
 through the "classpath setting". 
Let's say we have the following source code for Tester.java along
 with the directory structure shown below.
1 import com.abc.Abner; 
2 
3 public class Tester { 
4 Abner a = new Abner(); // Tester depends on Abner 
5 } // Tester 
 
C:\
 |
 +--Projects\
 |
 +--Tester.java
 |
 +--com\
 |
 +--abc\
 |
 +--com.abc.Abner.class
Now let's say we try to compile Tester.java with the following
 command line. Note that the current directory is C:\:
 
C:\>javac &#8209;classpath
 Projects Tester.java
The result of this attempt is the following error:
 
error: cannot read: Tester.java
 1 error
Even though Tester.java resides in the Projects directory
 (specified by the &#8209;classpath option) the Java compiler could not
 find it. As I mentioned earlier, this is because the -classpath
 option applies to secondary classes, not primary classes. The locations of all Java source
 files specified on the javac command line must be fully specified using either
 an absolute or relative path. Again, the -classpath and -sourcepath
 options are never used in locating the primary class files or source files.
 There are two ways to fix the previous
 error. First, we could issue the javac command using the Projects
 directory as the default directory, like this:
C:\Projects>javac Tester.java
or we could could fully specify the location of Tester.java like
 this:
C:\>javac &#8209;classpath
 Projects Projects\Tester.java
Notice that in the first case it was not necessary to specify the &#8209;classpath
 option since javac uses the current directory as the default classpath if the CLASSPATH variable is not set and the -classpath option is not specified. Since com.abc.Abner
 is in the Projects directory, this is perfectly fine. In the second example,
 however, it was necessary to specify the &#8209;classpath option since
 com.abc.Abner is not in the C:\ directory.
Here's the third important nugget of information you should remember from this
 article:
 
All primary classes (i.e., those classes contained in source files that
 were specified on the javac command line) are always compiled, regardless
 of whether or not their class files are up to date with their source files.
Remember that secondary classes are only compiled if their source files can
 be located and their source files are newer than the corresponding class
 files.
Hang in there, we're almost done. Now, when the Java compiler generates class
 files where does it put them? The answer to this question is the fourth important
 nugget of information:
 
If the &#8209;d command line option was specified, the generated class files
 are put in the specified directory; otherwise, they are put in the same directory
 as the source code that was compiled. The directory specified by &#8209;d is not automatically added to your user class path. 
Let's have a look at another example. Let's say we have the following source
 code for Tester.java and the following directory structure:
1 import com.abc.Abner; 
2 
3 public class Tester { 
4 Abner a = new Abner(); // Tester depends on Abner 
5 } // Tester 
 
C:\
 |
 +--Projects\
 |
 +--src\
 | |
 | +--Tester.java
 | |
 | +--com\
 | |
 | +--abc\
 | |
 | +--com.abc.Abner.java
 |
 +--classes\
We'll examine a couple ways for compiling Tester.java and the
 resulting consequences. When using the following command line,
 
C:\>javac -d Projects\classes
 &#8209;sourcepath Projects\src Projects\src\Tester.java
everything compiles fine and we end up with the following directory contents:
 
C:\
 |
 +--Projects\
 |
 +--src\
 | |
 | +--Tester.java
 | |
 | +--com\
 | |
 | +--abc\
 | |
 | +--com.abc.Abner.java
 |
 +--classes\
 |
 +--Tester.class
 |
 +--com\
 |
 +--abc\
 |
 +--com.abc.Abner.class
The -d option told javac to place all generated class files in
 the C:\Projects\classes directory. If the &#8209;d option
 had not been specified all class files would have been put in the same directory
 as their Java source code counterparts.
Now, here's an important point to note: Everytime you re-issue the previous
 javac command, com.abc.Abner.class will be regenerated, even though
 its source code has not changed. Why is this? Remember that when javac considers
 whether or not it should compile a secondary class (like com.abc.Abner)
 it tries to find both an existing class file and a source file. If it
 can find the source file but not the class file, it compiles the source file.
 This is exactly the situation we have here&#151;javac can find the source file
 for com.abc.Abner, but not the class file. Why can't the class file be found? Because
 it's not in the "classpath setting"!
If we want to ensure the classfiles are generated only when the source code
 changes, we could change the javac command to this:
 
C:\>javac &#8209;d Projects\classes &#8209;sourcepath Projects\src &#8209;classpath Projects\classes Projects\src\Tester.java
 
Now let's go back to our earlier source code and directory structure:
1 import com.abc.Abner; 
2 
3 public class Tester { 
4 Abner a = new Abner(); // Tester depends on Abner 
5 } // Tester 
 
C:\
 |
 +--Projects\
 |
 +--src\
 | |
 | +--Tester.java
 | |
 | +--com\
 | |
 | +--abc\
 | |
 | +--com.abc.Abner.java
 |
 +--classes\
What will be the result of using the following javac command?
 
C:\>javac &#8209;classpath
 Projects\classes &#8209;sourcepath Projects\src Projects\src\Tester.java
The resulting directory structure and its contents are shown below:
 
C:\
 |
 +--Projects\
 |
 +--src\
 | |
 | +--Tester.java
 | +--Tester.class
 | |
 | +--com\
 | |
 | +--abc\
 | |
 | +--com.abc.Abner.java
 | +--com.abc.Abner.class
 |
 +--classes\
Since the &#8209;d option was not specified, all class files were placed
 in the same directories as their Java source code counterparts. Furthermore,
 since the "classpath settings" (i.e., Projects\classes)
 will never contain any classes, com.abc.Abner.java will be compiled
 everytime the previous javac command is issued, even if Abner.java
 never changes. Once again, remember that javac will check if the source code
 files are newer than the class files before compiling the source files, but it can only do this if it can find both the class and source files. If
 the class files cannot be found in "classpath setting", javac will
 compile the source files (assuming it can find them) each and every time.
There is one subtle difference in using the &#8209;classpath option
 with javac versus Java As I mentioned, the &#8209;classpath option does not apply
 to the primary classes listed on the javac command line&#151;it only applies
 to the secondary classes. When using the Java command, however, the &#8209;classpath
 option does apply to the class listed on the command line
 (i.e., the class containing a main() method), as well as to any
 other classes referenced by this class. Note that when using the Java command,
 you can specify the command line option of &#8209;cp as a shorthand for
 &#8209;classpath.
 
Field Initialization and Type
Conversions During Assignment
If not given explicit initial values, all instance and class fields are automatically
initialized to their default values. Local fields, however,
require an explicit initial value. Each element of an allocated array is automatically
initialized to its default value, based on its type, regardless of whether the array is a local,
class or instance field.
When assigning values to a variable, a type conversion may be necessary if the source and target types are different. In the simplest case, a primitive widening conversion occurs transparently:
1 int i = 100; 
2 long l = i; // primitive widening conversion: int to long 
3 double d = l; // primitive widening conversion: long to double 
Java will graciously perform an implicit primitive narrowing conversion if the source value is an int constant expression whose value is within the range of the target type. Note that this statement implies that the target type is either of type char, byte, or short. Here's an example of implicit narrowing conversions:
1 byte b = -46; // implicit narrowing conversion: int to byte 
2 short s = 12; // implicit narrowing conversion: int to short 
3 char c = 62738; // implicit narrowing conversion: int to char 
A primitive narrowing conversion will also be applied if the source is a int variable which was declared as final and was initialized with an int constant. The code example below is based on an example in A
 Programmer's Guide to Java Certification, p.47:
1 // i is not final, It CANNOT be used as the source for a 
2 // narrowing primitive conversion. 
3 int i = -20; 
4 
5 // j is final *and* assigned an int constant. It can be used 
6 // as the source for a primitive narrowing conversion. 
7 final int j = 30 / 2; 
8 
9 // k is final but NOT assigned an int constant. It CANNOT be 
10 // used as the source for a primitive narrowing conversion. 
11 final int k = i; 
12 
13 byte b = j; // meets criteria for narrowing primitive conversion 
14 b = (byte)i; // cast require: does not meet criteria 
15 b = (byte)k; // cast require: does not meet criteria 
In this article we've discussed two main concepts:
 
	 
- We discussed the primitive widening conversion that occurs during assignment from a narrower type to a wider type. 
	 
- We discussed the implicit primitive narrowing conversion which has two flavors:
	
	 
- If the source value is an int constant and is within the range of the target type, Java will automatically convert it (i.e., narrow it) to the target type.
	 
- If the source value is a variable that was declared final and was assigned a constant value, Java will automatically convert it (i.e., narrow it) to the target type. The assignment of the variable, j, in the code above was an example of this situation.
	
	 
 
These two concepts were discussed in the context of assignments to variables. What happens when values are passed as parameters to methods? Do the same assignment behaviors apply? Yes and no. Primitive widening conversions apply to method parameter assignment but implicit narrowing conversions do not. In other words, you will have to use a cast rather than relying on Java's primitive narrowing conversion when passing an int constant as a method parameter declared as byte, short, or char. Here's an example:
1 public class Tester { 
2 public static void main(String[] args) { 
3 someMethod(12, (short)12); 
4 } // main() 
5 
6 private static void someMethod(double d, short s) {} 
7 } // Tester 
In this example we had to explicitly convert the second parameter to a short, even though the value of 12 is comfortably within the range of a short. Note that if we were simply assigning the 12 to a short variable rather than passing it as a method parameter, the cast would not have been necessary. The first parameter, however, the double parameter, was automatically converted from an int constant to a double by Java's primitive widening conversion&#151;no cast was required.
 
Primitive Widening Conversions
A "primitive widening conversion" is a conversion from one primitive datatype
(e.g., int) to wider primitive datatype (e.g., double).
Primitive widening conversions usually never result in a loss of data since the datatype
we are converting to can represent a "wider" range of values than the
type we are converting from.
There is a caveat to this rule. Mughal and Rasmussen describe it best on page 47 of A
Programmer's Guide to Java Certification:
 
"Integer values widened to floating-point values can result in a loss of precision. Magnitude (i.e., how big a value can be represented) must not be confused with precision (i.e., significant digits in the number). In the example below, the precision of the least significant bits of the long value may be lost when converting to a float value:"
1 long bigInteger = 98765432112345678L; 
2 float realNo = bigInteger; // Widening but loss of precision 
3 
4 System.out.println(bigInteger); 
5 System.out.println(realNo); 
The output from running this code is:
98765432112345678
9.8765436E16
So you can see that assigning the long to the float resulted in a loss of significant digits (i.e., precision), even though the assignment is perfectly acceptable according to Java's "primitive widening" rules.
A primitive narrowing conversion is a conversion
 from one datatype (e.g., float) to a narrower datatype (e.g., char).
 Narrowing conversions may result in a loss of data since the datatype we are
 converting to cannot represent the same range of values as the type
 we are converting from. Narrowing conversions often require
 a cast&#151;but not always. See the article, "Field Initialization and Type Conversions During Assignment", for a description of when narrowing conversions are performed implicitly. You may also want to review the article, "Know
 Your Primitive Types", to review the ranges for the various primitive types.
The figure below (taken from A
 Programmer's Guide to Java Certification, p.44) shows which Java primitive
 types can be converted to other primitive types through widening conversions.
 Note that widening conversions are transitive. Formally, if the conversion from
 type T1 to type T2 is a widening conversion
 and the conversion from type T2 to type T3
 is a widening conversion, then the conversion from type T1
 to type T3 is a widening conversion. Again, widening
 conversions do not require a cast and will not result in loss of data. Any conversion
 not implied by the diagram below is a narrowing conversion and therefore
 requires a cast and can result in a loss of data (except as noted in the "Field Initialization and Type Conversions During Assignment" article). Some examples of widening
 and narrowing conversions are shown in the code below.
 
byte ---> short
 \
 \
 ---> int ---> long ---> float ---> double
 /
 /
 char
1 byte b = 0; 
2 char c = 'A'; 
3 short s = 0; 
4 int i = 0; 
5 long l = 0L; 
6 float f = 0.0F; 
7 double d = 0.0; 
8 
9 f = l; // widening conversion 
10 l = (long)f; // narrowing conversion, requires cast 
11 d = b; // widening conversion 
12 b = (byte)s; // narrowing conversion, requires cast 
13 s = (short)c; // narrowing conversion, requires cast 
14 c = (char)s; // narrowing conversion, requires cast 
15 b = (byte)c; // narrowing conversion, requires cast 
16 b = (byte)s; // narrowing conversion, requires cast 
17 c = (char)b; // narrowing conversion, requires cast 
18 i = b; // widening conversion 
 
Unary Numeric Promotion
Unary numeric promotion (JLS
2, §5.6.1)
states that if the operand of a unary operator is of type byte, short,
or char, the operand will be promoted to a value of type
int by an implicit primitive
widening conversion, otherwise it is not converted. For a nice example of
unary numeric promotion (and binary numeric promotion), please see the tidbit,
Binary Numeric Promotion.
What is meant by a "unary operator"? A unary operator is an operator that takes
 a single operand. The unary numeric promotion rule above applies in the following
 situations:
 
- When an array is created, unary numeric promotion applies to the "dimension
 expression". For example, in the snippet below, the value in b
 is promoted to an int at line 2:
	 
	 
	 1 byte b = 40; 
2 int[] a = new int[b]; // b is automatically promoted to an int 
	 
 
 
- When an array element is accessed, unary numeric promotion applies to the
 "index expression". For example, in the snippet below the value in b
 is promoted to an int at line 3:
	 
	 
	 1 int[] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; 
2 byte b = 4; 
3 System.out.println(a[b]); // b is automatically promoted to an int 
	 
 
 
- When the unary plus (+) or minus (-) operators
 are used, unary numeric promotion applies to the operand. For example, in
 the snippet below, the expression, +b, is an int
 expression, even though b itself is a byte. Consequently,
 when we try to assign +b to b, we get a compiler
 error indicating a "possible loss of precision". That's because we are trying
 to assign an int (the expression +b) to a byte
 (the variable, b):
	 
	 
	 1 byte b = 40; 
2 b = +b; // COMPILER ERROR: We need to cast +b to a byte 
	 
 
 
- When the bitwise complement operator (~) is used, unary numeric
 promotion applies to the operand. The next example is almost identical to
 the previous one except that the ~ operator is used in place
 of the + operator. Once again, attempting to assign an int
 expression (~b) to a byte variable produces a compiler
 error indicating a "possible loss of precision":
	 
	 
	 1 byte b = 40; 
2 b = ~b; // COMPILER ERROR: We need to cast ~b to a byte 
	 
 
 
- When a shift operator (>, or
 >>>) is used, unary numeric promotion is applied to
 each operand separately. The shift operators are somewhat of an aberration
 in that they are binary rather than unary operators yet unary numeric promotion
 is applied to their operands individually.
 
 As an aside, note that the resulting type of a shift operation
 will always be the result of applying unary numeric promotion to the left
 operand -- i.e., it will always be either int or long.
 Why will this be the case? Because byte, short,
 and char are all promoted to int while long
 remains a long and float and double
 cannot participate in shift operations. Below is an example:
	 
	 
	 1 long l = -1; 
2 short s = 4; 
3 long result = l and >=.
	 
- the numerical equality operators: == and !=.
	 
- The integer bitwise operators: &, ^ and |.
	 
- In certain cases (JLS
 2, §15.25),
 to the second and third operands of the conditional operator: ? :.
 
Below is an example of how binary numeric promotion and unary numeric promotion
work. This example comes from page 51 of the seminal work, A
Programmer's Guide to Java Certification. The red bars (|)
indicate binary numeric promotion while the green bars (|)
indicate unary numeric promotion.
 ( d * i ) + ( f * -b ) - ( c / s )
 | | | | | |
 | | | | | |
 double int float byte char short
 | | | | | |
 | | | | | |
 | double | int int int
 | | | | | |
 | | | | | |
 | | | float | |
 | | | | | |
 |_____| |______| |_____|
 | | |
 | | |
 double float int
 | | |
 | | |
 | double |
 | | |
 |________________| |
 | |
 | |
 double double
 | |
 |_______________________|
 |
 |
 double
Sophisticated Primitive Types
When working with non-primitive types in Java it's easy to get the java.lang.Class object associated with a given class. You could either use the static forName() method in java.lang.Class or you could use a "class literal". A class literal is simply the name of the class (or interface or array or primitive type) followed by a "Class" suffix (JLS2, §15.8.2). A class literal is an object of type java.lang.Class. Note that you cannot obtain the java.lang.Class object for a primitive type by calling Class.forName(), although java.lang.Class class has a static, package-private, getPrimitiveClass() method.
When dealing with primitive types (including void), you can obtain the associated java.lang.Class objects by constructing a "class literal" as described above. In addition to class literals, each of Java's primitive wrapper classes has a public member representing the java.lang.Class of its primitive type. You can access this member by simply referring to .TYPE. 
Here's a little code that describes the various way to obtain/refer to the java.lang.Class objects of primitive types:
1 public class Tester { 
2 public static void main(String[] args) { 
3 Class i1 = int.class; 
4 Class i2 = Integer.TYPE; 
5 if(i1 == i2) 
6 System.out.println("They're the same..." + i1 + " " + i2); 
7 
8 Class v1 = void.class; 
9 Class v2 = Void.TYPE; 
10 if(v1 == v2) 
11 System.out.println("They're the same..." + v1 + " " + v2); 
12 } // main() 
13 } // Tester 
The output from running this code is:
They're the same...int int
They're the same...void void
Different Character Encodings Map to Different Bytes
When converting a Java String to an external byte representation, you can select which byte-encoding of the String to use. Here's a little program that creates a String of all possible characters (from Character.MIN_VALUE through Character.MAX_VALUE) and then converts the String to various encodings. Judging from the output, you can see that different encodings require a different number of bytes.
1 import java.io.*; 
2 
3 public class ByteEncodings { 
4 public static void main(String[] args) throws Exception { 
5 String[] encodings = {"US-ASCII", "ISO-8859-1", "UTF-8", "UTF-16BE", "UTF-16LE", "UTF-16"}; 
6 
7 StringBuffer sb = new StringBuffer(Character.MAX_VALUE + 1); 
8 
9 // Build up the big String. 
10 for(int j = Character.MIN_VALUE; j " + s2 + "\", with length " + s2.length()); 
14 
15 b2 = s2.getBytes(); 
16 System.out.println("b2's length is " + b2.length); 
17 } // main() 
18 } // Tester 
The output from running this program is:
 
s2 is: "Hello ", with length 10
b2's length is 10
Notice that the byte[], b2, is twice as large as b1. After line seven executes, b2 contains all zero bytes. Line 10 copies b1 into the "first half" of b2, leaving the second half of b2 with zero bytes. When s2 is created on line 12, the zero bytes in b2 become part of the s2 string. This accounts for the first line of output. When s2 is converted to a byte[] on line 15, the zero characters in s2 are stored in b2. This accounts for b2's length as shown in the second line of output.
In summary, "null characters" in a String are treated like any other character and "zero bytes" are treated as any other byte value in terms of conversion to characters.
URLConnection Uses HTTP POST
	to Send Data to HTTP URL
When data is written to an HTTP URLConnection, it is written using the HTTP POST method.
	
Here's a small snippet of code that creates a URLConnection and writes some text to it using a parameter named "string". This code takes a single command line argument (in args[0]) and writes it to the CGI script at http://java.sun.com/cgi-bin/backwards. The URL is a simple Perl script Sun has provided to reverse the text in the "string" paramter. Note that we must first URL-encode the text to be passed to the Perl script (line 3). The code on line 12 is key: it is this code that causes the POST method to be used rather than a GET method.
After the code listing is the full HTTP request sent to the HTTP server.
1 // First, we need to "URL-encode" the text to 
2 // be sent via the POST method. 
3 String stringToReverse = URLEncoder.encode(args[0], "UTF-8"); 
4 
5 // This URL is a little Perl script Sun has provided to 
6 // simply reverse the text sent to it in the paramerter named, 
7 // "string". 
8 URL url = new URL("http://java.sun.com/cgi-bin/backwards"); 
9 URLConnection connection = url.openConnection(); 
10 
11 // The next statement is what causes the POST method to be used. 
12 connection.setDoOutput(true); 
13 
14 PrintWriter out = new PrintWriter(connection.getOutputStream()); 
15 out.println("string=" + stringToReverse); // send the "string" 
16 out.close(); 
Here's the HTTP request sent to the server (note that eachrepresents a carriage return/linefeed):
	
POST /cgi-bin/backwards HTTP/1.1">
User-Agent: Java1.4.0
Host: java.sun.com
Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2
Connection: keep-alive
Content-type: application/x-www-form-urlencoded 
Content-length: 46
string=This+is+a+line+of+text+to+be+reversed
Unique Identifiers, Really
	
I once worked on a project where we needed to generate a unique filename for every file that was received via FTP. The silly solution I came up with was to simply append a time/date stamp onto the file's name. This turned out not to be a good solution. I ended up trying to rename files to names that were already in use.
	
The Java class libraries provide a very handy class that is guaranteed to generate a unique object always and forever. The class is java.rmi.server.UID. I won't go into details because the javadocs are adequate in explaining it. If you ever find yourself in a position where you need to generate a guaranteed unique identifier, remember this handy little class.
	
 
 
Copyright © 1999-2002, Tony LaPaso
 All Rights Reserved.
